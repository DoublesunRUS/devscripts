#!/usr/bin/executor

/*******************************************************************************
 * Copyright (c) 2021 Alexander Kapralov and Contributors
 * This program and the accompanying materials are made available under
 * the terms of the BSD 3-Clause License which is available at
 * https://spdx.org/licenses/BSD-3-Clause.html#licenseText
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * Contributors:
 *    
 *
 ******************************************************************************/

метод ПреобразоватьОшибкиВФорматSonarCube(файлSonarQube: Строка, файлРезультатовВалидации: Строка)
	знч данныеОшибок = ОшибкиВФорматеSonarCube(файлРезультатовВалидации)

	ЗаписатьОшибкиВФорматSonarCube(файлSonarQube, данныеОшибок)
;

метод ОшибкиВФорматеSonarCube(файлРезультатовВалидации: Строка): SonarqubeGenericFormat
	знч файл = новый Файл(файлРезультатовВалидации)
	исп поток = файл.ОткрытьПотокЧтения()

	пер issues = новый Массив()
	пер rules = новый Массив()
	пер соответствиеПравил = новый Соответствие()

	знч чтение = новый ЧтениеДанных(поток)
	пока не чтение.ЧтениеЗавершено()
		знч строкаДанных = чтение.ПрочитатьСтроку()
		если строкаДанных.Пусто()
		продолжить
		;

		знч описаниеОшибки = ОшибкаEDT(строкаДанных)
		если описаниеОшибки == Неопределено
		продолжить
		;

		знч issue = IssueИзСтрокиTSV(описаниеОшибки)
		issues.Добавить(issue)

		соответствиеПравил.Вставить(issue.ruleId, RuleИзIssue(issue))
	;

	для правило из соответствиеПравил
		rules.Добавить(правило.Значение)
	;

	возврат новый SonarqubeGenericFormat(issues, rules)
;

метод ЗаписатьОшибкиВФорматSonarCube(файлSonarQube: Строка, данныеОшибок: SonarqubeGenericFormat)
	знч файлПараметров = новый Файл(файлSonarQube)
	исп поток = файлПараметров.ОткрытьПотокЗаписи()

	СериализацияJson.ЗаписатьОбъект(поток, данныеОшибок)
;


/* 
 * Sonarqube API
 */
структура SonarqubeGenericFormat
	знч issues: Массив
	знч rules: Массив
;

структура SonarqubeTextRange
	знч startLine: Число

//	пер endLine: Число = 0
//	пер startColumn: Число = 0
//	пер endColumn: Число = 0
	конструктор(startLine)
;

структура SonarqubeLocation
	знч message: Строка
	знч filePath: Строка
	пер textRange: SonarqubeTextRange?

	конструктор(message, filePath)
;


перечисление SonarqubeType
	BUG,
	VULNERABILITY,
	CODE_SMELL
;

перечисление SonarqubeSeverity
	BLOCKER,
	CRITICAL,
	MAJOR,
	MINOR,
	INFO
;


структура SonarqubeIssue
	знч engineId: Строка
	знч ruleId: Строка
	знч primaryLocation: SonarqubeLocation
	знч type: SonarqubeType
	знч severity: SonarqubeSeverity

//	пер effortMinutes: Число = 0
//	пер secondaryLocations: SonarqubeLocation?
	конструктор(engineId, ruleId, primaryLocation, type, severity)
;

структура BslLsRule
	знч engineId: Строка
	знч ruleId: Строка
	знч name: Строка
	знч type: SonarqubeType
	знч severity: SonarqubeSeverity
	знч description: Строка
;


метод DecToHex(десятичноеЧисло: Число): Строка
	пер база = 16

	пер результат = ""

	пока десятичноеЧисло != 0
		пер поз = десятичноеЧисло % база

		результат = "0123456789ABCDEF".Символ(поз) + результат

		десятичноеЧисло = (десятичноеЧисло / база).ЦелаяЧасть()
	;
	результат = "0000" + результат

	возврат результат.ПодстрокаСКонца(4)
;

метод СтрокуВUnicode(исходнаяСтрока: Строка): Строка
	пер результат = ""

	пер кодыДопустимыхСимволов = новый Массив()
	кодыДопустимыхСимволов.Добавить(1105) // "ё"
	кодыДопустимыхСимволов.Добавить(1025) // "Ё"

	для номер = 0 по исходнаяСтрока.Длина() - 1
		знч кодСимвола = Символы.ПолучитьКод(исходнаяСтрока.Символ(номер))
		знч оставить = ((кодСимвола < 1040) или (кодСимвола > 1103)) и (кодыДопустимыхСимволов.Найти(кодСимвола) == Неопределено)
		если оставить
			результат += исходнаяСтрока.Символ(номер)
		иначе
			результат += "\\u" + DecToHex(кодСимвола)
		;
	;

	возврат результат
;

метод СохранитьНастройкиСканера(имяФайлаПараметров: Строка, сервер: Строка, ключПроекта: Строка,
	наименованиеПроекта: Строка, версияПроекта: Строка, путьКонфигурацииЕДТ: Строка, файлSonarQube: Строка)
	знч файлПараметров = новый Файл(имяФайлаПараметров)
	исп поток = файлПараметров.ОткрытьПотокЗаписи()

	пер запись = новый ЗаписьДанных(поток)

	знч наименованиеПроектаUnicode = СтрокуВUnicode(наименованиеПроекта)
	знч путьКонфигурацииЕДТUnicode = СтрокуВUnicode(путьКонфигурацииЕДТ.Заменить("\\", "/"))
	знч файлSonarQubeUnicode = СтрокуВUnicode(файлSonarQube.Заменить("\\", "/"))

	запись.ЗаписатьСтроку("sonar.host.url=%сервер")
	запись.ЗаписатьСтроку("sonar.projectKey=%ключПроекта")
	запись.ЗаписатьСтроку("sonar.projectName=%наименованиеПроектаUnicode (%ключПроекта)")
	запись.ЗаписатьСтроку("sonar.projectVersion=%версияПроекта")
	запись.ЗаписатьСтроку("sonar.sourceEncoding=UTF-8")
	запись.ЗаписатьСтроку("sonar.inclusions=**/*.bsl")
	запись.ЗаписатьСтроку("sonar.sources=src")
	запись.ЗаписатьСтроку("sonar.projectBaseDir=%путьКонфигурацииЕДТUnicode")
	запись.ЗаписатьСтроку("sonar.scm.enabled=true")
	запись.ЗаписатьСтроку("sonar.scm.provider=git")
	запись.ЗаписатьСтроку("sonar.externalIssuesReportPaths=%файлSonarQubeUnicode")
	запись.ЗаписатьСтроку("sonar.bsl.languageserver.enabled=false")
;

метод ЗапуститьSonarScanner(имяФайлаПараметров: Строка, токен: Строка, путьSonarScanner: Строка)
	пер имяКоманды = ""
	знч версияОС = ИспользуемаяОС()
	выбор версияОС
	когда ОперационныеСистемы.Windows
		имяКоманды = "%путьSonarScanner/bin/sonar-scanner.bat"
	иначе
		имяКоманды = "%путьSonarScanner/bin/sonar-scanner"
	;

	знч временныйФайлЛогов = Файлы.СоздатьВременныйФайл()

	пер параметры = новый Массив()
	параметры.Добавить("-Dproject.settings=\"%имяФайлаПараметров\"")
	параметры.Добавить("-D\"sonar.login=%токен\"")
	параметры.Добавить(">%{временныйФайлЛогов.Путь}")

	пер процесс = новый ПроцессОс(имяКоманды, параметры, Ложь)
	процесс.Запустить()
	пер количествоВыведенныхСтрок = 0
	пока не процесс.ОжидатьЗавершения(60с) и процесс.Живой()
		если временныйФайлЛогов.Существует()
			исп логВыполненияСкрипта = временныйФайлЛогов.ОткрытьПотокЧтения()
			знч текстЛога = логВыполненияСкрипта.ПрочитатьКакСтроку(КодировкаПотокаВыводаПлатформы())
			знч строкиЛога = текстЛога.Разделить(Символы.НоваяСтрока)
			если строкиЛога.Размер() > количествоВыведенныхСтрок
				знч текстСообщения = Строки.Соединить(строкиЛога.ПодМассив(количествоВыведенныхСтрок), Символы
					.НоваяСтрока)
				количествоВыведенныхСтрок = строкиЛога.Размер()
				Консоль.Записать(текстСообщения)
			;
			логВыполненияСкрипта.Закрыть()
		;
	;
	если временныйФайлЛогов.Существует()
		исп логВыполненияСкрипта = временныйФайлЛогов.ОткрытьПотокЧтения()
		знч текстЛога = логВыполненияСкрипта.ПрочитатьКакСтроку(КодировкаПотокаВыводаПлатформы())
		знч строкиЛога = текстЛога.Разделить(Символы.НоваяСтрока)
		если строкиЛога.Размер() > количествоВыведенныхСтрок
			знч текстСообщения = Строки.Соединить(строкиЛога.ПодМассив(количествоВыведенныхСтрок), Символы.НоваяСтрока)
			количествоВыведенныхСтрок = строкиЛога.Размер()
			Консоль.Записать(текстСообщения)
		;
		логВыполненияСкрипта.Закрыть()
		Файлы.Удалить(временныйФайлЛогов)
	;

	знч кодВозврата = процесс.ПолучитьКодВозврата()

	если кодВозврата == 0
		Консоль.Записать("SonarQube Scanner успешно запущен.")
	возврат
	;

	пер текстОшибки = "Код возврата: %кодВозврата"

	текстОшибки += Строки.Шаблон("\в\нКоманда: $0\в\нПараметры: $1", [имяКоманды, Строки.Соединить(параметры, " ")])

	исп ошибкиВыполненияСкрипта = процесс.ПолучитьПотокОшибок()
	текстОшибки += "\в\н" + ошибкиВыполненияСкрипта.ПрочитатьКакСтроку(КодировкаПотокаВыводаПлатформы())
	выбросить новый ИсключениеНедопустимоеСостояние(текстОшибки)
;

метод КодировкаПотокаВыводаПлатформы(): Строка
	если ИспользуемаяОС() == ОперационныеСистемы.Windows
		возврат "windows-1251"
	;

	возврат "UTF-8"
;


перечисление ОперационныеСистемы
	Windows,
	MacOS,
	Linux
;


метод ИспользуемаяОС(): ОперационныеСистемы
	знч имяОС = СредаИсполнения.ПолучитьСвойство("os.name")

	выбор когда имяОС.НачинаетсяС("windows", Истина)
		возврат ОперационныеСистемы.Windows

	когда имяОС.Содержит("mac", Истина)
		возврат ОперационныеСистемы.MacOS

	когда имяОС.Содержит("nux", Истина)
		возврат ОперационныеСистемы.Linux

	иначе
		выбросить новый ИсключениеНедопустимоеСостояние("Неизвестная ОС")
	;
;


перечисление ОшибкаEDTКритичность
	Блокирующая,
	Критическая,
	Значительная,
	Незначительная,
	Тривиальная
;


структура ОписаниеОшибкиEDT
	знч создано: ДатаВремя
	знч критичность: ОшибкаEDTКритичность
	знч проект: Строка
	знч объект: Строка
	знч положение: Число
	знч описание: Строка
	пер источник: Строка
	пер ид: Строка
	пер контекст: Массив

	конструктор(создано, критичность, проект, ид, объект, положение, описание)
;


метод ОшибкаEDT(строкаДанных: Строка): ОписаниеОшибкиEDT?
	знч массивДанных = строкаДанных.Разделить(Символы.Таб, Истина)

	если массивДанных[3].Пусто() или массивДанных[5].Пусто() или не массивДанных[5].НачинаетсяС("строка")
		возврат Неопределено
	;

	знч создано = новый ДатаВремя(массивДанных[0].Подстрока(0, 19))
	знч положение = Число(массивДанных[5].Подстрока(7))

	пер критичность = ОшибкаEDTКритичность.Тривиальная
	выбор массивДанных[1]
	когда "Блокирующая"
		критичность = ОшибкаEDTКритичность.Блокирующая
		
	когда "Критическая"
		критичность = ОшибкаEDTКритичность.Критическая
		
	когда "Значительная"
		критичность = ОшибкаEDTКритичность.Значительная
		
	когда "Незначительная"
		критичность = ОшибкаEDTКритичность.Незначительная
		
	когда "Тривиальная"
		критичность = ОшибкаEDTКритичность.Тривиальная
		
	иначе
		критичность = ОшибкаEDTКритичность.Значительная
//		выбросить новый ИсключениеНедопустимоеСостояние("Неизвестная критичность %{массивДанных[1]}")
		
	;

	пер описаниеОшибки = новый ОписаниеОшибкиEDT(создано, критичность, массивДанных[2], массивДанных[3], массивДанных[4],
		положение, массивДанных[6])
	описаниеОшибки.источник = "EDT"

	возврат описаниеОшибки
;

метод IssueИзСтрокиTSV(описаниеОшибки: ОписаниеОшибкиEDT): SonarqubeIssue
	знч engineId = описаниеОшибки.источник
	знч ruleId = описаниеОшибки.ид
	пер primaryLocation = новый SonarqubeLocation(описаниеОшибки.описание, ПутьКФайлуПоОбъекту(описаниеОшибки))
	primaryLocation.textRange = новый SonarqubeTextRange(описаниеОшибки.положение)

	пер type = SonarqubeType.CODE_SMELL

	пер severity = SonarqubeSeverity.INFO
	выбор описаниеОшибки.критичность
	когда ОшибкаEDTКритичность.Блокирующая
		severity = SonarqubeSeverity.BLOCKER
		type = SonarqubeType.BUG
		
	когда ОшибкаEDTКритичность.Критическая
		severity = SonarqubeSeverity.CRITICAL
		type = SonarqubeType.BUG
		
	когда ОшибкаEDTКритичность.Значительная
		severity = SonarqubeSeverity.MAJOR
		type = SonarqubeType.BUG
		
	когда ОшибкаEDTКритичность.Незначительная
		severity = SonarqubeSeverity.MINOR
		type = SonarqubeType.BUG
		
	;

	знч issue = новый SonarqubeIssue(engineId, ruleId, primaryLocation, type, severity)

	возврат issue
;

метод RuleИзIssue(issue: SonarqubeIssue): BslLsRule
	возврат новый BslLsRule(issue.engineId, issue.ruleId, issue.ruleId, issue.type, issue.severity, issue.ruleId)
;

метод ПутьКФайлуПоОбъекту(описаниеОшибки: ОписаниеОшибкиEDT): Строка
	пер массивОбъекта = описаниеОшибки.объект.Разделить(".")

	пер объектМетаданных = массивОбъекта[0]
	выбор объектМетаданных
	когда "РегистрБухгалтерии"
		объектМетаданных = "AccountingRegisters"
	когда "РегистрНакопления"
		объектМетаданных = "AccumulationRegisters"
	когда "БизнесПроцесс"
		объектМетаданных = "BusinessProcesses"
	когда "РегистрРасчета"
		объектМетаданных = "CalculationRegisters"
	когда "Справочник"
		объектМетаданных = "Catalogs"
	когда "ПланСчетов"
		объектМетаданных = "ChartsOfAccounts"
	когда "ПланВидовРасчета"
		объектМетаданных = "ChartsOfCalculationTypes"
	когда "ПланВидовХарактеристик"
		объектМетаданных = "ChartsOfCharacteristicTypes"
	когда "ГруппаКоманд"
		объектМетаданных = "CommandGroups"
	когда "ОбщаяКоманда"
		объектМетаданных = "CommonCommands"
	когда "ОбщаяФорма"
		объектМетаданных = "CommonForms"
	когда "ОбщийМодуль"
		объектМетаданных = "CommonModules"
	когда "Конфигурация"
		объектМетаданных = "Configuration"
	когда "Константа"
		объектМетаданных = "Constants"
	когда "Обработка"
		объектМетаданных = "DataProcessors"
	когда "ЖурналДокумента"
		объектМетаданных = "DocumentJournals"
	когда "Документ"
		объектМетаданных = "Documents"
	когда "Перечисление"
		объектМетаданных = "Enums"
	когда "ПодпискаНаСобытие"
		объектМетаданных = "EventSubscriptions"
	когда "ПланОбмена"
		объектМетаданных = "ExchangePlans"
	когда "КритерийОтбора"
		объектМетаданных = "FilterCriteria"
	когда "HTTPСервис"
		объектМетаданных = "HTTPServices"
	когда "РегистрСведений"
		объектМетаданных = "InformationRegisters"
	когда "Отчет"
		объектМетаданных = "Reports"
	когда "ХранилищеНастроек"
		объектМетаданных = "SettingsStorages"
	когда "Задача"
		объектМетаданных = "Tasks"
	когда "WebСервис"
		объектМетаданных = "WebServices"
	когда "WSСсылка"
		объектМетаданных = "WSReferences"
	иначе
		выбросить новый ИсключениеНедопустимоеСостояние("Неизвестный объект метаданных %{описаниеОшибки.объект}")
	;

	пер имяМодуля = массивОбъекта[массивОбъекта.Размер() - 1]
	выбор имяМодуля
	когда "МодульКоманды"
		имяМодуля = "CommandModule"
	когда "МодульУправляемогоПриложения"
		имяМодуля = "ManagedApplicationModule"
	когда "МодульМенеджера"
		имяМодуля = "ManagerModule"
	когда "Модуль"
		имяМодуля = "Module"
	когда "МодульОбъекта"
		имяМодуля = "ObjectModule"
	когда "МодульОбычногоПриложения"
		имяМодуля = "OrdinaryApplicationModule"
	когда "МодульНабораЗаписей"
		имяМодуля = "RecordSetModule"
	когда "МодульСеанса"
		имяМодуля = "SessionModule"
	когда "МодульМенеджераЗначения"
		имяМодуля = "ValueManagerModule"
	иначе
		выбросить новый ИсключениеНедопустимоеСостояние("Неизвестный модуль %{описаниеОшибки.объект}")
	;

	массивОбъекта.УдалитьПоИндексу(0)
	массивОбъекта.УдалитьПоИндексу(массивОбъекта.Размер() - 1)
	пер наименованиеОбъекта = массивОбъекта[0]
	массивОбъекта.УдалитьПоИндексу(0)
	если массивОбъекта.Размер() == 1
		если массивОбъекта[0] != "Форма"
			выбросить новый ИсключениеНедопустимоеСостояние("Не удалось определить объект %{описаниеОшибки.объект}")
		;
	
	иначе если массивОбъекта.Размер() > 1
		выбор массивОбъекта[0]
		когда "Форма"
			наименованиеОбъекта += "\\Forms\\%{массивОбъекта[1]}"
		когда "Команда"
			наименованиеОбъекта += "\\Commands\\%{массивОбъекта[1]}"
		иначе
			выбросить новый ИсключениеНедопустимоеСостояние("Неизвестный вид объекта %{массивОбъекта[0]}")
		;
	
	;

	возврат "src\\%объектМетаданных\\%наименованиеОбъекта\\%имяМодуля.bsl"
;